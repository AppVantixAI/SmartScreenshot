import AppKit
import Defaults
import Sauce

class Clipboard {
    static let shared = Clipboard()
  
  // Smart clipboard coordination to prevent duplicate processing
  private var isSmartScreenshotProcessing = false
  private var lastProcessedContentHash = 0
  
  typealias OnNewCopyHook = (HistoryItem) -> Void

  private var onNewCopyHooks: [OnNewCopyHook] = []
  var changeCount: Int
  private var lastAddedContent: String? = nil
  
  // SINGLE POINT OF ENTRY: All clipboard history additions must go through here
  private var isProcessingClipboardAddition = false
  private var lastAddedContentHash = 0
  
  // Helper function to get current clipboard content for debouncing
  private func getCurrentContent() -> String? {
    return pasteboard.string(forType: .string)
  }

  private let pasteboard = NSPasteboard.general

  private var timer: Timer?

  private let dynamicTypePrefix = "dyn."
  private let microsoftSourcePrefix = "com.microsoft.ole.source."
  private let supportedTypes: Set<NSPasteboard.PasteboardType> = [
    .fileURL,
    .html,
    .png,
    .rtf,
    .string,
    .tiff
  ]
  private let ignoredTypes: Set<NSPasteboard.PasteboardType> = [
    .autoGenerated,
    .concealed,
    .transient
  ]

  private var enabledTypes: Set<NSPasteboard.PasteboardType> { Defaults[.enabledPasteboardTypes] }
  private var disabledTypes: Set<NSPasteboard.PasteboardType> { supportedTypes.subtracting(enabledTypes) }

  private var sourceApp: NSRunningApplication? { NSWorkspace.shared.frontmostApplication }

  init() {
    changeCount = pasteboard.changeCount
  }

  func onNewCopy(_ hook: @escaping OnNewCopyHook) {
    onNewCopyHooks.append(hook)
  }

  func clearHooks() {
    onNewCopyHooks = []
  }
  
  // SINGLE POINT OF ENTRY: All clipboard history additions must go through here
  @MainActor
  func addToClipboardHistory(_ historyItem: HistoryItem) -> Bool {
    // Prevent multiple simultaneous additions
    guard !isProcessingClipboardAddition else {
      print("ðŸš« SINGLE POINT OF ENTRY: Already processing clipboard addition - BLOCKING")
      return false
    }
    
    // Create content fingerprint for duplicate detection
    let contentFingerprint = createContentFingerprint(historyItem.contents)
    
    // Check if this content was already processed
    if contentFingerprint == lastAddedContentHash {
      print("ðŸš« SINGLE POINT OF ENTRY: Duplicate content detected - BLOCKING")
      return false
    }
    
    // Mark as processing and add to history
    isProcessingClipboardAddition = true
    lastAddedContentHash = contentFingerprint
    
    // Add to the main history system
    History.shared.add(historyItem)
    
    // CRITICAL: Force save after adding to ensure persistence
    Storage.shared.forceSave()
    
    // Resume processing after a short delay
    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
      self.isProcessingClipboardAddition = false
    }
    
    print("âœ… SINGLE POINT OF ENTRY: Added to clipboard history: '\(historyItem.title.prefix(50))...'")
    return true
  }
  
  // Helper function to create content fingerprint
  private func createContentFingerprint(_ contents: [HistoryItemContent]) -> Int {
    var hasher = Hasher()
    for content in contents.sorted(by: { $0.type < $1.type }) {
      hasher.combine(content.type)
      hasher.combine(content.value?.count ?? 0)
      if let data = content.value {
        hasher.combine(data.prefix(100)) // Use first 100 bytes for performance
      }
    }
    return hasher.finalize()
  }
  
  // Smart clipboard coordination methods
  func setSmartScreenshotProcessing(_ isProcessing: Bool) {
    isSmartScreenshotProcessing = isProcessing
    if isProcessing {
      print("ðŸ”„ SmartScreenshot is processing - pausing main clipboard monitoring")
    } else {
      print("ðŸ”„ SmartScreenshot processing complete - resuming main clipboard monitoring")
    }
  }
  
  func markContentAsProcessed(_ contentHash: Int) {
    lastProcessedContentHash = contentHash
    print("ðŸ”„ Content marked as processed by SmartScreenshot: \(contentHash)")
  }

  func start() {
    timer = Timer.scheduledTimer(
      timeInterval: Defaults[.clipboardCheckInterval],
      target: self,
      selector: #selector(checkForChangesInPasteboard),
      userInfo: nil,
      repeats: true
    )
  }

  func restart() {
    timer?.invalidate()
    start()
  }

  @MainActor
  func copy(_ string: String) {
    pasteboard.clearContents()
    pasteboard.setString(string, forType: .string)
    sync()
    checkForChangesInPasteboard()
  }

  @MainActor
  func copy(_ item: HistoryItem?, removeFormatting: Bool = false) {
    guard let item else { return }

    pasteboard.clearContents()
    var contents = item.contents

    if removeFormatting {
      contents = clearFormatting(contents)
    }

    for content in contents {
      guard content.type != NSPasteboard.PasteboardType.fileURL.rawValue else { continue }
      pasteboard.setData(content.value, forType: NSPasteboard.PasteboardType(content.type))
    }

    // Use writeObjects for file URLs so that multiple files that are copied actually work.
    // Only do this for file URLs because it causes an issue with some other data types (like formatted text)
    // where the item is pasted more than once.
    let fileURLItems: [NSPasteboardItem] = contents.compactMap { item in
      guard item.type == NSPasteboard.PasteboardType.fileURL.rawValue else { return nil }
      guard let value = item.value else { return nil }
      let pasteItem = NSPasteboardItem()
      pasteItem.setData(value, forType: NSPasteboard.PasteboardType(item.type))
      return pasteItem
    }
    pasteboard.writeObjects(fileURLItems)

    pasteboard.setString("", forType: .fromSmartScreenshot)
    pasteboard.setString(item.application ?? "", forType: .source)
    sync()

    Task {
      Notifier.notify(body: item.title, sound: .knock)
      checkForChangesInPasteboard()
    }
  }

  // Based on https://github.com/Clipy/Clipy/blob/develop/Clipy/Sources/Services/PasteService.swift.
  func paste() {
    Accessibility.check()

    // Add flag that left/right modifier key has been pressed.
    // See https://github.com/TermiT/Flycut/pull/18 for details.
    let cmdFlag = CGEventFlags(rawValue: UInt64(KeyChord.pasteKeyModifiers.rawValue) | 0x000008)
    var vCode = Sauce.shared.keyCode(for: KeyChord.pasteKey)

    // Force QWERTY keycode when keyboard layout switches to
    // QWERTY upon pressing âŒ˜ key (e.g. "Dvorak - QWERTY âŒ˜").
    // See https://github.com/p0deje/SmartScreenshot/issues/482 for details.
    if KeyboardLayout.current.commandSwitchesToQWERTY && cmdFlag.contains(.maskCommand) {
      vCode = KeyChord.pasteKey.QWERTYKeyCode
    }

    let source = CGEventSource(stateID: .combinedSessionState)
    // Disable local keyboard events while pasting
    source?.setLocalEventsFilterDuringSuppressionState([.permitLocalMouseEvents, .permitSystemDefinedEvents],
                                                       state: .eventSuppressionStateSuppressionInterval)

    let keyVDown = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: true)
    let keyVUp = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: false)
    keyVDown?.flags = cmdFlag
    keyVUp?.flags = cmdFlag
    keyVDown?.post(tap: .cgSessionEventTap)
    keyVUp?.post(tap: .cgSessionEventTap)
  }

  func clear() {
    guard Defaults[.clearSystemClipboard] else {
      return
    }

    pasteboard.clearContents()
  }

  @objc
  @MainActor
  func checkForChangesInPasteboard() {
    let currentChangeCount = pasteboard.changeCount
    
    guard currentChangeCount != changeCount else { return }
    
    // Production-proven validation: Check for meaningful content before processing
    guard let currentContent = getCurrentContent(),
          !currentContent.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty else {
      print("ðŸš« Clipboard change detected but content is empty - skipping")
      changeCount = currentChangeCount
      return
    }
    
    // Smart clipboard coordination: Skip if SmartScreenshot is processing
    if isSmartScreenshotProcessing {
      print("ðŸ”„ Skipping clipboard processing - SmartScreenshot is handling this content")
      changeCount = currentChangeCount
      return
    }
    
    // Debounce: Check if this is the same content as recently added
    if let currentContent = getCurrentContent(),
       let lastContent = lastAddedContent,
       currentContent == lastContent {
      print("ðŸ”„ Debouncing duplicate clipboard content: '\(currentContent.prefix(50))...'")
      changeCount = currentChangeCount
      return
    }
    
    // Get the current content for debouncing
    lastAddedContent = getCurrentContent()
    
    if Defaults[.ignoreEvents] {
      if Defaults[.ignoreOnlyNextEvent] {
        Defaults[.ignoreEvents] = false
        Defaults[.ignoreOnlyNextEvent] = false
      }
      return
    }
    
    // Reading types on NSPasteboard gives all the available
    // types - even the ones that are not present on the NSPasteboardItem.
    // See https://github.com/p0deje/SmartScreenshot/issues/241.
    if shouldIgnore(Set(pasteboard.types ?? [])) {
      return
    }
    
    if let sourceAppBundle = sourceApp?.bundleIdentifier, shouldIgnore(sourceAppBundle) {
      return
    }
    
    // Some applications (BBEdit, Edge) add 2 items to pasteboard when copying
    // so it's better to merge all data into a single record.
    // - https://github.com/p0deje/SmartScreenshot/issues/78
    // - https://github.com/p0deje/SmartScreenshot/issues/472
    var contents = [HistoryItemContent]()
    pasteboard.pasteboardItems?.forEach({ item in
      var types = Set(item.types)
      if types.contains(.string) && isEmptyString(item) && !richText(item) {
        return
      }
      
      if shouldIgnore(item) {
        return
      }
      
      types = types
        .subtracting(disabledTypes)
        .filter { !$0.rawValue.starts(with: dynamicTypePrefix) }
        .filter { !$0.rawValue.starts(with: microsoftSourcePrefix) }
      
      // Avoid reading Microsoft Word links from bookmarks and cross-references.
      // https://github.com/p0deje/SmartScreenshot/issues/613
      // https://github.com/p0deje/SmartScreenshot/issues/770
      if types.isSuperset(of: [.microsoftLinkSource, .microsoftObjectLink]) {
        types = types.subtracting([.microsoftLinkSource, .microsoftObjectLink, .pdf])
      }
      
      types.forEach { type in
        contents.append(HistoryItemContent(type: type.rawValue, value: item.data(forType: type)))
      }
    })
    
    guard !contents.isEmpty else {
      return
    }
    
    let historyItem = HistoryItem(contents: contents)
    historyItem.application = sourceApp?.bundleIdentifier
    historyItem.title = historyItem.generateTitle()
    
    // Use SINGLE POINT OF ENTRY to prevent duplicates
    let success = addToClipboardHistory(historyItem)
    if success {
      print("âœ… Main clipboard: Successfully added via single point of entry")
    } else {
      print("ðŸš« Main clipboard: Duplicate blocked by single point of entry")
    }
    
    changeCount = currentChangeCount
  }

  private func shouldIgnore(_ types: Set<NSPasteboard.PasteboardType>) -> Bool {
    let ignoredTypes = self.ignoredTypes
      .union(Defaults[.ignoredPasteboardTypes].map({ NSPasteboard.PasteboardType($0) }))

    return types.isDisjoint(with: enabledTypes) ||
      !types.isDisjoint(with: ignoredTypes)
  }

  private func shouldIgnore(_ sourceAppBundle: String) -> Bool {
    if Defaults[.ignoreAllAppsExceptListed] {
      return !Defaults[.ignoredApps].contains(sourceAppBundle)
    } else {
      return Defaults[.ignoredApps].contains(sourceAppBundle)
    }
  }

  private func shouldIgnore(_ item: NSPasteboardItem) -> Bool {
    for regexp in Defaults[.ignoreRegexp] {
      if let string = item.string(forType: .string) {
        do {
          let regex = try NSRegularExpression(pattern: regexp)
          if regex.numberOfMatches(in: string, range: NSRange(string.startIndex..., in: string)) > 0 {
            return true
          }
        } catch {
          return false
        }
      }
    }
    return false
  }

  private func isEmptyString(_ item: NSPasteboardItem) -> Bool {
    guard let string = item.string(forType: .string) else {
      return true
    }

    return string.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
  }

  private func richText(_ item: NSPasteboardItem) -> Bool {
    if let rtf = item.data(forType: .rtf) {
      if let attributedString = NSAttributedString(rtf: rtf, documentAttributes: nil) {
        return !attributedString.string.isEmpty
      }
    }

    if let html = item.data(forType: .html) {
      if let attributedString = NSAttributedString(html: html, documentAttributes: nil) {
        return !attributedString.string.isEmpty
      }
    }

    return false
  }

  // Some applications requires window be unfocused and focused back to sync the clipboard.
  // - Chrome Remote Desktop (https://github.com/p0deje/SmartScreenshot/issues/948)
  // - Netbeans (https://github.com/p0deje/SmartScreenshot/issues/879)
  private func sync() {
    guard let app = sourceApp,
          app.bundleURL?.lastPathComponent == "Chrome Remote Desktop.app" ||
            app.localizedName?.contains("NetBeans") == true else {
      return
    }

    NSApp.activate(ignoringOtherApps: true)
    NSApp.hide(self)
  }

  private func clearFormatting(_ contents: [HistoryItemContent]) -> [HistoryItemContent] {
    var newContents: [HistoryItemContent] = contents
    let stringContents = contents.filter { NSPasteboard.PasteboardType($0.type) == .string }

    // If there is no string representation of data,
    // behave like we didn't have to remove formatting.
    if !stringContents.isEmpty {
      newContents = stringContents

      // Preserve file URLs.
      // https://github.com/p0deje/SmartScreenshot/issues/962
      let fileURLContents = contents.filter { NSPasteboard.PasteboardType($0.type) == .fileURL }
      if !fileURLContents.isEmpty {
        newContents += fileURLContents
      }
    }

    return newContents
  }
}
